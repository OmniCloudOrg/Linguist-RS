//! Detection of generated source code files.
//!
//! This module provides functionality to identify files that are generated
//! by tools rather than written by humans.

use regex::Regex;
use std::path::Path;

lazy_static::lazy_static! {
    // Regular expressions for various generated code patterns
    static ref XCODE_REGEX: Regex = Regex::new(r"\.(nib|xcworkspacedata|xcuserstate)$").unwrap();
    static ref IDEA_REGEX: Regex = Regex::new(r"(?:^|\/)\.idea\/").unwrap();
    static ref COCOAPODS_REGEX: Regex = Regex::new(r"(^Pods|\/Pods)\/").unwrap();
    static ref CARTHAGE_BUILD_REGEX: Regex = Regex::new(r"(^|\/)Carthage\/Build\/").unwrap();
    static ref NODE_MODULES_REGEX: Regex = Regex::new(r"node_modules\/").unwrap();
    static ref COMPOSER_LOCK_REGEX: Regex = Regex::new(r"composer\.lock$").unwrap();
    static ref CARGO_LOCK_REGEX: Regex = Regex::new(r"Cargo\.lock$").unwrap();
    static ref GENERATED_COMMENT_REGEX: Regex = Regex::new(r"^\s*// (Code )?Generated by\b").unwrap();
    static ref GENERATED_GRAPHQL_REGEX: Regex = Regex::new(r"__generated__\/").unwrap();
    
    // Minified file patterns
    static ref MINIFIED_EXTENSIONS: Regex = Regex::new(r"(\.|-)min\.(js|css)$").unwrap();
    
    // Source Map file patterns
    static ref SOURCE_MAP_EXTENSIONS: Regex = Regex::new(r"\.js\.map$|\.css\.map$").unwrap();
    
    // Fixed: Split the problematic regex into separate patterns to avoid the curly brace issues
    static ref SOURCE_MAP_JSON_START: Regex = Regex::new(r#"^\{"version":3,"#).unwrap();
    static ref SOURCE_MAP_LINE_MAPS: Regex = Regex::new(r#"^/\*\* Begin line maps\. \*\*/"#).unwrap();
    static ref SOURCE_MAP_URL: Regex = Regex::new(r#"^\s*//[@#] sourceMappingURL="#).unwrap();
}

/// Functionality for detecting generated files
pub struct Generated;

impl Generated {
    /// Check if a file is generated based on its name and contents
    ///
    /// # Arguments
    ///
    /// * `name` - The name/path of the file
    /// * `data` - The content of the file
    ///
    /// # Returns
    ///
    /// * `bool` - True if the file is detected as generated
    pub fn is_generated(name: &str, data: &[u8]) -> bool {
        // Check filename patterns for known generated files
        if Self::xcode_file(name) || 
           Self::intellij_file(name) || 
           Self::cocoapods(name) || 
           Self::carthage_build(name) || 
           Self::node_modules(name) ||
           Self::composer_lock(name) ||
           Self::cargo_lock(name) ||
           Self::generated_graphql_relay(name) {
            return true;
        }
        
        // Check file content for generated code patterns
        if data.is_empty() {
            return false;
        }
        
        // Check for minified files
        if Self::minified_js_or_css(name) && Self::is_minified_content(data) {
            return true;
        }
        
        // Check for source maps
        if Self::is_source_map(name, data) {
            return true;
        }
        
        // Check first line for common "Generated by..." comments
        if let Ok(content) = std::str::from_utf8(data) {
            if let Some(first_line) = content.lines().next() {
                if GENERATED_COMMENT_REGEX.is_match(first_line) {
                    return true;
                }
            }
        }
        
        false
    }
    
    /// Check if the file is an Xcode file
    fn xcode_file(name: &str) -> bool {
        XCODE_REGEX.is_match(name)
    }
    
    /// Check if the file is in an IntelliJ IDEA project directory
    fn intellij_file(name: &str) -> bool {
        IDEA_REGEX.is_match(name)
    }
    
    /// Check if the file is part of Pods directory
    fn cocoapods(name: &str) -> bool {
        COCOAPODS_REGEX.is_match(name)
    }
    
    /// Check if the file is part of Carthage/Build directory
    fn carthage_build(name: &str) -> bool {
        CARTHAGE_BUILD_REGEX.is_match(name)
    }
    
    /// Check if the file is part of node_modules
    fn node_modules(name: &str) -> bool {
        NODE_MODULES_REGEX.is_match(name)
    }
    
    /// Check if the file is a composer.lock file
    fn composer_lock(name: &str) -> bool {
        COMPOSER_LOCK_REGEX.is_match(name)
    }
    
    /// Check if the file is a Cargo.lock file
    fn cargo_lock(name: &str) -> bool {
        CARGO_LOCK_REGEX.is_match(name)
    }
    
    /// Check if the file is a generated GraphQL Relay file
    fn generated_graphql_relay(name: &str) -> bool {
        GENERATED_GRAPHQL_REGEX.is_match(name)
    }
    
    /// Check if the file has a minified extension
    fn minified_js_or_css(name: &str) -> bool {
        MINIFIED_EXTENSIONS.is_match(name)
    }
    
    /// Check if the content appears to be minified
    fn is_minified_content(data: &[u8]) -> bool {
        if let Ok(content) = std::str::from_utf8(data) {
            let lines: Vec<&str> = content.lines().collect();
            
            // No lines or only one line
            if lines.is_empty() {
                return false;
            }
            
            // Check if there are few lines with long average line length
            if !lines.is_empty() {
                let total_length: usize = lines.iter().map(|line| line.len()).sum();
                let avg_line_length = total_length / lines.len();
                
                // Consider it minified if average line length is over 110 chars
                if avg_line_length > 110 {
                    return true;
                }
            }
        }
        
        false
    }
    
    /// Check if the file is a source map
    fn is_source_map(name: &str, data: &[u8]) -> bool {
        // Check if it has a .map extension
        if SOURCE_MAP_EXTENSIONS.is_match(name) {
            return true;
        }
        
        // Check content for source map patterns
        if let Ok(content) = std::str::from_utf8(data) {
            if let Some(first_line) = content.lines().next() {
                // Modified: Use individual regex patterns instead of one combined pattern
                if SOURCE_MAP_JSON_START.is_match(first_line) ||
                   SOURCE_MAP_LINE_MAPS.is_match(first_line) ||
                   SOURCE_MAP_URL.is_match(first_line) {
                    return true;
                }
            }
        }
        
        false
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_xcode_detection() {
        assert!(Generated::xcode_file("project.xcworkspacedata"));
        assert!(Generated::xcode_file("project.xcuserstate"));
        assert!(Generated::xcode_file("MyView.nib"));
        assert!(!Generated::xcode_file("MyCode.swift"));
    }
    
    #[test]
    fn test_intellij_detection() {
        assert!(Generated::intellij_file(".idea/workspace.xml"));
        assert!(Generated::intellij_file("project/.idea/misc.xml"));
        assert!(!Generated::intellij_file("idea_file.txt"));
    }
    
    #[test]
    fn test_node_modules_detection() {
        assert!(Generated::node_modules("node_modules/lodash/index.js"));
        assert!(Generated::node_modules("project/node_modules/react/index.js"));
        assert!(!Generated::node_modules("src/components/node_module_like.js"));
    }
    
    #[test]
    fn test_minified_detection() {
        assert!(Generated::minified_js_or_css("jquery.min.js"));
        assert!(Generated::minified_js_or_css("styles.min.css"));
        assert!(!Generated::minified_js_or_css("jquery.js"));
        
        // Test minified content
        let minified_js = "function x(){var a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9,j=10,k=11,l=12,m=13,n=14,o=15,p=16,q=17,r=18,s=19,t=20,u=21,v=22,w=23,x=24,y=25,z=26;return a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+r+s+t+u+v+w+x+y+z;}";
        assert!(Generated::is_minified_content(minified_js.as_bytes()));
        
        let normal_js = "function sum(a, b) {\n  return a + b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}";
        assert!(!Generated::is_minified_content(normal_js.as_bytes()));
    }
    
    #[test]
    fn test_source_map_detection() {
        assert!(Generated::is_source_map("script.js.map", &[]));
        assert!(Generated::is_source_map("styles.css.map", &[]));
        
        let source_map_content = r#"{"version":3,"sources":["original.js"],"names":[],"mappings":"AAAA;AACA;AACA;","file":"generated.js"}"#;
        assert!(Generated::is_source_map("maps.txt", source_map_content.as_bytes()));
    }
    
    #[test]
    fn test_generated_comment_detection() {
        let generated_js = "// Generated by CoffeeScript 1.12.7\nvar x = 5;";
        assert!(Generated::is_generated("script.js", generated_js.as_bytes()));
        
        let generated_proto = "// Code generated by protoc-gen-go. DO NOT EDIT.\npackage main";
        assert!(Generated::is_generated("message.pb.go", generated_proto.as_bytes()));
        
        let normal_code = "// This is a regular comment\nfunction main() {}";
        assert!(!Generated::is_generated("normal.js", normal_code.as_bytes()));
    }
}